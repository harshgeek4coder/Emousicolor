# -*- coding: utf-8 -*-
"""Untitled.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18bnZ1iVAhgoYYwO4rQ-8r0PosnnhPj9v
"""

import tensorflow as tf



from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC


#driver = webdriver.Chrome(r"C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe") 
emotion=str(input("Enter the emotion : "))


if emotion == "ANGRY":
    wrds = ["Maroon 5 - Memories", "The Weeknd - Blinding Lights", "Lloyd P White - Burst Part 2"]
    kwrd = ["maroon", "weeknd", "lloyd"]
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    driver = webdriver.Chrome(r"C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe",chrome_options=chrome_options)

    for i, j in zip(wrds, kwrd):
       driver.get("https://www.youtube.com/")
       WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input#search"))).send_keys(i)
       driver.find_element_by_css_selector("button.style-scope.ytd-searchbox#search-icon-legacy").click()
       WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "h3.title-and-badge.style-scope.ytd-video-renderer a"))).click()
       WebDriverWait(driver, 10).until(EC.title_contains(j))
       print(driver.current_url)
       driver.quit()

from selenium import webdriver 
import pandas as pd 
from selenium.webdriver.common.by import By 
from selenium.webdriver.support.ui import WebDriverWait 
from selenium.webdriver.support import expected_conditions as EC

from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC

options = webdriver.ChromeOptions() 
options.add_argument("start-maximized")
options.add_experimental_option("excludeSwitches", ["enable-automation"])
options.add_experimental_option('useAutomationExtension', False)
driver = webdriver.Chrome(options=options, executable_path=r'C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe')
baseurl = "http://youtube.com"
keyword = input()
driver.get(f'{baseurl}/search?q={keyword}')
print([my_elem.text for my_elem in WebDriverWait(driver, 20).until(EC.visibility_of_all_elements_located((By.XPATH, "//yt-formatted-string[@class='style-scope ytd-video-renderer' and @aria-label]")))])
driver.quit()

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import webbrowser
import random


def get_music_emo(emo):
    list1=[]    
    if emo=='HAPPY üòÄ':
        wrds = ["Vivaldi four seasons", "The Beatles twist and shout", "50 cent heat"]
        kwrd = ["Vivaldi", "Beatles", "50"]
        options = webdriver.ChromeOptions()
        options.add_argument("start-maximized")
        options.add_argument("disable-infobars")
        options.add_argument("--disable-extensions")
        driver=webdriver.Chrome(chrome_options=options, executable_path=r'C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe')
        for i, j in zip(wrds, kwrd):
            driver.get("https://www.youtube.com/")
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input#search"))).send_keys(i)
            driver.find_element_by_css_selector("button.style-scope.ytd-searchbox#search-icon-legacy").click()
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "h3.title-and-badge.style-scope.ytd-video-renderer a"))).click()
            WebDriverWait(driver, 10).until(EC.title_contains(j))
            list1.append(driver.current_url)

        driver.quit()
        webbrowser.open(random.choice(list1))
    elif emo=='SAD üôÅ':
        wrds = ["Alec Benjamin - Let Me Down Slowly", "Trevor Daniel - Falling ", "Marshmello ft. Bastille - Happier"]
        kwrd = ["Slowly", "Falling", "Happier"]
        options = webdriver.ChromeOptions()
        options.add_argument("start-maximized")
        options.add_argument("disable-infobars")
        options.add_argument("--disable-extensions")
        driver=webdriver.Chrome(chrome_options=options, executable_path=r'C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe')
        for i, j in zip(wrds, kwrd):
            driver.get("https://www.youtube.com/")
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input#search"))).send_keys(i)
            driver.find_element_by_css_selector("button.style-scope.ytd-searchbox#search-icon-legacy").click()
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "h3.title-and-badge.style-scope.ytd-video-renderer a"))).click()
            WebDriverWait(driver, 10).until(EC.title_contains(j))
            list1.append(driver.current_url)

        driver.quit()
        webbrowser.open(random.choice(list1))  




    elif emo=='ANGRY üò°':
        wrds = ["Alec Benjamin - Let Me Down Slowly", "Trevor Daniel - Falling ", "Marshmello ft. Bastille - Happier"]
        kwrd = ["Slowly", "Falling", "Happier"]
        options = webdriver.ChromeOptions()
        options.add_argument("start-maximized")
        options.add_argument("disable-infobars")
        options.add_argument("--disable-extensions")
        driver=webdriver.Chrome(chrome_options=options, executable_path=r'C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe')
        for i, j in zip(wrds, kwrd):
            driver.get("https://www.youtube.com/")
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input#search"))).send_keys(i)
            driver.find_element_by_css_selector("button.style-scope.ytd-searchbox#search-icon-legacy").click()
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "h3.title-and-badge.style-scope.ytd-video-renderer a"))).click()
            WebDriverWait(driver, 10).until(EC.title_contains(j))
            list1.append(driver.current_url)

        driver.quit()
        webbrowser.open(random.choice(list1))  

    elif emo=='NEUTRAL üòê':
        wrds = ["Alec Benjamin - Let Me Down Slowly", "Trevor Daniel - Falling ", "Marshmello ft. Bastille - Happier"]
        kwrd = ["Let Me Down Slowly", "Falling", "Happier"]
        options = webdriver.ChromeOptions()
        options.add_argument("start-maximized")
        options.add_argument("disable-infobars")
        options.add_argument("--disable-extensions")
        driver=webdriver.Chrome(chrome_options=options, executable_path=r'C:\Users\Harsh\Downloads\chromedriver_win32 (1)\chromedriver.exe')
        for i, j in zip(wrds, kwrd):
            driver.get("https://www.youtube.com/")
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "input#search"))).send_keys(i)
            driver.find_element_by_css_selector("button.style-scope.ytd-searchbox#search-icon-legacy").click()
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "h3.title-and-badge.style-scope.ytd-video-renderer a"))).click()
            WebDriverWait(driver, 10).until(EC.title_contains(j))
            list1.append(driver.current_url)

        driver.quit()
        webbrowser.open(random.choice(list1))

get_music_emo('HAPPY üòÄ')

import cv2, numpy as np, argparse, time, glob, os, sys, subprocess, pandas, random, Update_Model, math, ctypes, win32con
#Define variables and load classifier
camnumber = 0
video_capture = cv2.VideoCapture()
facecascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")
fishface = cv2.createFisherFaceRecognizer()
try:
    fishface.load("trained_emoclassifier.xml")
except:
    print("no trained xml file found, please run program with --update flag first")
parser = argparse.ArgumentParser(description="Options for the emotion-based music player")
parser.add_argument("--update", help="Call to grab new images and update the model accordingly", action="store_true")
parser.add_argument("--retrain", help="Call to re-train the the model based on all images in training folders", action="store_true") #Add --update argument
parser.add_argument("--wallpaper", help="Call to run the program in wallpaper change mode. Input should be followed by integer for how long each change cycle should last (in seconds)", type=int) #Add --update argument
args = parser.parse_args()
facedict = {}
actions = {}
emotions = ["angry", "happy", "sad", "neutral"]
df = pandas.read_excel("EmotionLinks.xlsx") #open Excel file
actions["angry"] = [x for x in df.angry.dropna()] #We need de dropna() when columns are uneven in length, which creates NaN values at missing places. The OS won't know what to do with these if we try to open them.
actions["happy"] = [x for x in df.happy.dropna()]
actions["sad"] = [x for x in df.sad.dropna()]
actions["neutral"] = [x for x in df.neutral.dropna()]
def crop_face(clahe_image, face):
    for (x, y, w, h) in face:
        faceslice = clahe_image[y:y+h, x:x+w]
        faceslice = cv2.resize(faceslice, (350, 350))
    facedict["face%s" %(len(facedict)+1)] = faceslice
    return faceslice
def update_model(emotions):
    print("Model update mode active")
    check_folders(emotions)
    for i in range(0, len(emotions)):
        save_face(emotions[i])
    print("collected images, looking good! Now updating model...")
    Update_Model.update(emotions)
    print("Done!")
def check_folders(emotions):
    for x in emotions:
        if os.path.exists("dataset\\%s" %x):
            pass
        else:
            os.makedirs("dataset\\%s" %x)
def save_face(emotion):
    print("\n\nplease look " + emotion + ". Press enter when you're ready to have your pictures taken")
    raw_input() #Wait until enter is pressed with the raw_input() method
    video_capture.open(camnumber)
    while len(facedict.keys()) < 16:
        detect_face()
    video_capture.release()
    for x in facedict.keys():
        cv2.imwrite("dataset\\%s\\%s.jpg" %(emotion, len(glob.glob("dataset\\%s\\*" %emotion))), facedict[x])
    facedict.clear()
def recognize_emotion():
    predictions = []
    confidence = []
    for x in facedict.keys():
        pred, conf = fishface.predict(facedict[x])
        cv2.imwrite("images\\%s.jpg" %x, facedict[x])
        predictions.append(pred)
        confidence.append(conf)
    recognized_emotion = emotions[max(set(predictions), key=predictions.count)]
    print("I think you're %s" %recognized_emotion)
    return recognized_emotion
def grab_webcamframe():
    ret, frame = video_capture.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    clahe_image = clahe.apply(gray)
    return clahe_image
def detect_face():
    clahe_image = grab_webcamframe()
    face = facecascade.detectMultiScale(clahe_image, scaleFactor=1.1, minNeighbors=15, minSize=(10, 10), flags=cv2.CASCADE_SCALE_IMAGE)
    if len(face) == 1:
        faceslice = crop_face(clahe_image, face)
        return faceslice
    else:
        print("no/multiple faces detected, passing over frame")
def run_detection():
    while len(facedict) != 10:
        detect_face()
    recognized_emotion = recognize_emotion()
    return recognized_emotion
def wallpaper_timer(seconds):
    video_capture.release()
    time.sleep(int(seconds))
    video_capture.open(camnumber)
    facedict.clear()
def change_wallpaper(emotion):
    files = glob.glob("wallpapers\\%s\\*.bmp" %emotion)
    current_dir = os.getcwd()
    random.shuffle(files)
    file = "%s\%s" %(current_dir, files[0])
    setWallpaperWithCtypes(file)
def setWallpaperWithCtypes(path): #Taken from http://www.blog.pythonlibrary.org/2014/10/22/pywin32-how-to-set-desktop-background/
    cs = ctypes.c_buffer(path)
    ok = ctypes.windll.user32.SystemParametersInfoA(win32con.SPI_SETDESKWALLPAPER, 0, cs, 0)
if args.update:
    update_model(emotions)
elif args.retrain:
    Update_Model.update(emotions)
elif args.wallpaper:
    cycle_time = args.wallpaper
    while True:
        wallpaper_timer(cycle_time)
        recognized_emotion = run_detection()
        change_wallpaper(recognized_emotion)
else:
    video_capture.open(camnumber)
    recognized_emotion = run_detection()
    actionlist = [x for x in actions[recognized_emotion]] #get list of actions/files for detected emotion
    random.shuffle(actionlist) #Randomly shuffle the list

import ctypes
def change_wp(abspath):    
    return ctypes.windll.user32.SystemParametersInfoW(20, 0, r"abspath" , 0)

!pip install py-wallpaper

import os
happy_path=r'C:\Users\Harsh\Desktop\Colours\HAPPY\sam1.png'
import ctypes
def change_wp(abspath):    
    return ctypes.windll.user32.SystemParametersInfoW(20, 0, r"abspath" , 0)
change_wp(happy_path)

import win32api, win32con, win32gui, random, time

def SetWallPaper(path):
    key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER,
                                "Control Panel\\\\Desktop",
                                0,win32con.KEY_SET_VALUE)
    win32api.RegSetValueEx(key, "WallpaperStyle", 0, win32con.REG_SZ, "0")
    win32api.RegSetValueEx(key, "TileWallpaper", 0, win32con.REG_SZ, "0")
    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, path, 1+2)

path = r"D:\[Working]Test Mod Obj Det\Wallpapers\anthony-tuil-lS_eDob6DDg-unsplash.jpg"
SetWallPaper(path)

import os
path=r"D:\[Working]Test Mod Obj Det\Wallpapers"
wallpapers=["1.jpg","2.jpg","3.jpg","4.jpg","5.jpg","6.jpg","7.jpg","8.jpg","9.jpg"]

for i in range(0,len(wallpapers)):
    print(os.path.join(path,wallpapers[i]))

import time 
import os
path=r"D:\[Working]Test Mod Obj Det\Wallpapers\Happy & Neutral"
happy=["green.png","pink.png","yellow.png"]
sad=["blue.png","purple.png","grey.png"]

hp=r"\Happy & Neutral"

fp=os.path.join(path,happy[i])
sad_path=os.path.join(path,sad[2])
# define the countdown func. 

def wall_countdown(t): 
    
    while t: 
        mins, secs = divmod(t, 60) 
        
        timer = '{:02d}:{:02d}'.format(mins, secs) 
       
        print("Wallpaper Will Change In : ",timer, end="\r") 
        
        time.sleep(1) 
       
        t -= 1
        

    SetWallPaper(fp) 
    time.sleep(5)
    SetWallPaper(fp)
    
    print(fp)
    print('\nWallpaper Changed') 
  
  

wall_countdown(int(5))







import time 
import os

import win32api
import win32gui
import win32con

h_path=r"D:\[Working]Test Mod Obj Det\Wallpapers\Happy & Neutral"
s_path=r"D:\[Working]Test Mod Obj Det\Wallpapers\Sad & Angry"
colours=["1.jpg","2.jpg","3.jpg"]
happy=["green.jpg","pink.jpg","yellow.jpg"]
sad=["blue.jpg","purple.jpg","grey.jpg"]
hp=r"\Happy & Neutral"
sp=r"\Sad & Angry"

def wallpaper(path):
    key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER,"Control Panel\\Desktop",0,win32con.KEY_SET_VALUE)
    win32api.RegSetValueEx(key, "WallpaperStyle", 0, win32con.REG_SZ, "0")
    win32api.RegSetValueEx(key, "TileWallpaper", 0, win32con.REG_SZ, "0")
    win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, path, 1+2)


    
    
    

def emo_wall(emotion):
    while emotion:
        for i in range(0,3):
            time.sleep(5)
            if emotion=="HAPPY":
                fp=os.path.join(h_path,happy[i])
            elif emotion=="SAD":
                fp=os.path.join(s_path,sad[i])
            print(fp)
            wallpaper(fp)

emo_wall("SAD")

emo_wall("HAPPY")

